---
title: "Algoritmos Gen칠ticos aplicados al recorrido de Parques Nacionales"
output: 
  html_document:
    theme: flatly 
runtime: shiny
---


***Algoritmos Gen칠ticos aplicados al recorrido de Parques Nacionales de la Rep칰plica Argentina***

### Contexto del problema

Este trabajo aborda un problema cl치sico de **optimizaci칩n combinatoria**, an치logo al *Problema del Viajante (TSP)*, aplicado al recorrido eficiente entre Parques Nacionales de la Rep칰blica Argentina.

El objetivo es **minimizar la distancia total recorrida**, utilizando **Algoritmos Gen칠ticos (GA)** como t칠cnica heur칤stica de b칰squeda, adecuada para espacios de soluciones grandes donde los m칠todos exactos resultan computacionalmente costosos.

**Nota sobre los datos**

Las coordenadas geogr치ficas corresponden a ubicaciones aproximadas de referencia de cada parque y se utilizan con fines **did치cticos y de modelado**, no para navegaci칩n real.


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
options(repos = c(CRAN = "https://cran.rstudio.com/"))
```


**Librer칤as**

```{r}
# Instalar paquetes si no est치n instalados
if(!require(GA)) install.packages("GA", dependencies = TRUE)  # Instala la librer칤a GA si no est치 instalada #Dependencies = T signigica que instalamos paquetes si es que estan desinstalados para que pueda funcionar
if(!require(leaflet)) install.packages("leaflet", dependencies = TRUE)  # Instala la librer칤a leaflet si no est치 instalada
if(!require(geosphere)) install.packages("geosphere", dependencies = TRUE)  # Instala la librer칤a geosphere si no est치 instalada

#Cargar librer칤as
library(GA)
library(leaflet)
library(geosphere)
library(readxl)

```

**Set de datos**
Extra칤dos de Sistema de Informaci칩n de Biodiversidad (https://sib.gob.ar/listado_parques.php?accion=parques)

```{r}
#Datos
areas_protegidas <- read_excel("areas_protegidas.xlsx")
areas_protegidas

```


**Exploraci칩n, transformaci칩n y limpieza de datos**

```{r}
str(areas_protegidas)
```


```{r}
areas_protegidas <- areas_protegidas[-1,]
colnames(areas_protegidas) <- areas_protegidas[1,]
areas_protegidas <- areas_protegidas[-1,]
areas_protegidas <- areas_protegidas[,c("츼REA PROTEGIDA", "LATITUD","LONGITUD")]
colnames(areas_protegidas) <- c("Area_protegida", "Latitud", "Longitud")
rownames(areas_protegidas) <- NULL
areas_protegidas$Area_protegida <- as.factor(areas_protegidas$Area_protegida)
areas_protegidas$Latitud <- as.numeric(areas_protegidas$Latitud)
areas_protegidas$Longitud <- as.numeric(areas_protegidas$Longitud)
str(areas_protegidas)
```


**Selecci칩n aleatoria de parques y obtenci칩n de matriz de distancias**
Para reducir la complejidad computacional y facilitar la visualizaci칩n, se selecciona aleatoriamente un subconjunto de parques.  
Cada ejecuci칩n puede producir un conjunto diferente de parques y, por lo tanto, un recorrido 칩ptimo distinto.

```{r}
#Seleccionar 10 parques aleatoriamente
library(dplyr)
set.seed(200)
areas_protegidas <- areas_protegidas %>% sample_n(15)
n <- nrow(areas_protegidas) #Se asigna a n el n칰mero de filas a partir de un subconjutno que elije 10 filas aleatoriamente

# Crear matriz de distancias geogr치ficas usando la funci칩n distGeo de geosphere
D <- matrix(0, nrow = n, ncol = n)  # Creamos una matriz de ceros para almacenar las distancias entre parques

#C치lculo de distancias que se almacenan en la matriz
for (i in 1:n) { #Para los parques almacenados como filas en i
  for (j in 1:n) { #Para los parques almacenados como columnas en j
    D[i, j] <- distGeo(c(areas_protegidas$Longitud[i], areas_protegidas$Latitud[i]), 
                       c(areas_protegidas$Longitud[j], areas_protegidas$Latitud[j])) / 1000  #Para todos los i y j de la matriz D, calcular la distancia con distGeo, con argumentos distGeo (p1(long,lat),p2(long,lat)) 
  }
}
D
```

**Obtenci칩n de las distancias en funci칩n de distintos recorridos**

```{r}
# Funci칩n que calcula la distancia total de un recorrido
trayectoria <- function(recorrido) { #Funcion que recibe de argumento un vector que indica el orden del recorrido de los parques, del 1 al 10
  total_dist <- 0  # Inicializa la variable para acumular la distancia total
  for (i in 1:(length(recorrido) - 1)) {  #Se crea un ciclo for que itera desde 1 hasta la longitud del vector -1, evitando que en el siguiente paso se produzca un error al sumar 1 en la 칰ltima posici칩n del recorrido
    total_dist <- total_dist + D[recorrido[i], recorrido[i + 1]]  #A la distancia actual, aumenta el valor de la distancia que existe entre el elemento i del vector recorrido, que representa el parque actual en el itinerario, y el siguiente elemento, que es pr칩ximo parque.
  }
  return(total_dist)  # Devuelve la distancia total del recorrido
}

```

**Funci칩n fitness**

```{r}
#Definic칩n de la funci칩n fitness
GA_objetivo <- function(x){
        return(-trayectoria(x))#Funci칩n tal que devuelva la trayectoria m칤nima. Se coloca un signo menos porque el algoritmo GA busca maximizar, entonces le indicamos que realice el procedimiento inverso
}
```

### Algoritmo Gen칠tico

Los Algoritmos Gen칠ticos simulan procesos evolutivos naturales mediante:
- Poblaciones de soluciones
- Operadores de cruce y mutaci칩n
- Selecci칩n basada en aptitud (*fitness*)

En este caso, cada individuo representa un **orden posible de visita de los parques**.

**Ejecuci칩n del algoritmo GA**

```{r}
# Ejecutar el algoritmo gen칠tico
ga_modelo <- ga(
        type = "permutation", #El algoritmo generar치 y optimizar치 permutaciones, es decir, recorridos con un determinado orden
        fitness = GA_objetivo, #Establecemos como funci칩n fitness la definida anteriormente
        lower = 1, upper = n, #El recorrido se genera con valores que van de 1 a n
        popSize = 10, #Tama침o de la poblaci칩n o n칰mero de soluciones posibles
        maxiter = 500, #N칰mero m치ximo de iteraciones
        pmutation = 0.2 #Probabilidad de que se genere una mutaci칩n, es decir, una variaci칩n en los recorridos
)
```

**Obtenci칩n del recorrido 칩ptimo**

```{r}

# Obtener la mejor soluci칩n (el recorrido 칩ptimo)
ruta_optima <- ga_modelo@solution[1, ]  # ga_modelo@solution es un objeto que contiene una matriz con las posibles soluciones. Extraemos la primera soluci칩n que es el mejor recorrido encontrado por el GA
DistanciaOptima <- -ga_modelo@fitnessValue  # La mejor distancia encontrada (negada porque el GA maximiza)
ruta_optima
DistanciaOptima

```

**Mapa interactivo**
El mapa interactivo permite visualizar:
- La ubicaci칩n espacial de los parques
- El recorrido 칩ptimo encontrado por el algoritmo
- La relaci칩n espacial entre provincias y 치reas protegidas

La visualizaci칩n facilita la interpretaci칩n geogr치fica del resultado del modelo.


```{r}
pacman::p_load(devtools, leaflet, rnaturalearth, rnaturalearthdata, sf, rnaturalearthhires, install = T) 
```


```{r}
# Cargar los l칤mites nacionales de Argentina (directamente como sf)
pais_arg <- ne_countries(country = "Argentina", returnclass = "sf")

# Descargar las provincias de Argentina (directamente como sf)
provincias_arg <- ne_states(country = "Argentina", returnclass = "sf")

```


```{r}
# Crear el mapa interactivo
mapa <- leaflet() %>%
  addProviderTiles("Esri.WorldImagery") %>%  # Fondo satelital
  setView(lng = mean(areas_protegidas$Longitud), lat = mean(areas_protegidas$Latitud), zoom = 5)  # Centrar mapa

# A침adir los l칤mites provinciales
mapa <- mapa %>%
  addPolygons(
    data = provincias_arg,
    fillColor = "#93a31c",  # Verde opaco para representar 치reas naturales
    fillOpacity = 0.4,  # Ligera transparencia para que no opaque el fondo
    color = "#66347e",  # Verde m치s oscuro para los bordes provinciales
    weight = 2,  # Grosor de las l칤neas provinciales
    popup = ~name  # Muestra el nombre de la provincia al hacer clic
  )

# A침adir los l칤mites nacionales de Argentina
mapa <- mapa %>%
  addPolygons(
    data = pais_arg,
    fillColor = "transparent",  # Sin relleno para no tapar el fondo
    color = "#003f00",  # Verde oscuro para la frontera nacional
    weight = 4  # Grosor de la l칤nea de borde
  )
# A침adir los museos como marcadores
for (i in 1:n) {
  mapa <- mapa %>%
   addCircleMarkers(
    lng = areas_protegidas$Longitud, lat = areas_protegidas$Latitud,
    color = "#228B22", # Verde oscuro
    fillColor = "#390c44", # Verde claro
    fillOpacity = 0.7, # Transparencia del relleno
    radius = 6, # Tama침o del c칤rculo
    popup = areas_protegidas$Area_protegida[i])  # A침ade un marcador por cada museo
}

# A침adir la l칤nea del recorrido 칩ptimo
ruta_lat <- areas_protegidas$Latitud[ruta_optima]  # Latitudes del recorrido 칩ptimo
ruta_lng <- areas_protegidas$Longitud[ruta_optima]  # Longitudes del recorrido 칩ptimo
mapa <- mapa %>%
  addPolylines(lng = ruta_lng, lat = ruta_lat, 
    color = "#006400", # Verde m치s oscuro para contrastar
    weight = 4, # Aumentamos el grosor de la l칤nea
    opacity = 0.7, # Le damos algo de transparencia para no tapar los detalles del mapa
    dashArray = "10,5" 
    )# L칤nea punteada para hacerla m치s visible)  # Dibuja una l칤nea que conecta los museos en el recorrido 칩ptimo

# Mostrar el mapa
mapa  # Muestra el mapa interactivo

# Mostrar la distancia 칩ptima y el recorrido de los museos
cat("Distancia 칩ptima encontrada:", DistanciaOptima, "km\n")  # Imprime la distancia m칤nima
cat("Recorrido 칩ptimo de los Parques Nacionales:\n")
for (i in 1:length(ruta_optima)) {
  cat(i, "-", areas_protegidas$Area_protegida[ruta_optima[i]], "\n")  # Imprime el nombre de los museos en el orden del recorrido 칩ptimo
}
```

**Buscar los mejores par치metros**

```{r}
# Funci칩n para buscar los mejores hiperpar치metros
buscar_mejores_hiperparametros <- function(hyper_iters = 10) { ## Indica que iterar치 10 veces buscando los par치metros
    mejor_distancia <- Inf   #Inicializa la mejor distancia con infinito ya que queremos minimizarla
    mejores_parametros <- NULL  # Inicializamos el contenedor de mejores par치metros en null hasta que encontremos los mejores 
    
    for (i in 1:hyper_iters) { #Se ejecuta hyper_iters veces, es decir 10. 
            #Cada iteraci칩n devuelve un conjunto de hyper par치metros
        
        # Selecci칩n aleatoria de los hiperpar치metros en cada iteraci칩n:
        n_poblacion <- sample(c(10, 20, 50), 1)  # Selecciona aleatoriamente un valor de la lista para el tama침o de la poblaci칩n entre 10, 20 y 50
        cxpb <- runif(1, 0.4, 0.9)  # Selecciona un n칰mero de probabilidad de cruce aleatoria entre 0.4 y 0.9
        mutpb <- runif(1, 0.1, 0.3)  # Selecciona un n칰mero de probabilidad de mutaci칩n aleatoria entre 0.1 y 0.3
        ngen <- sample(c(100, 300, 500), 1)  # Selecciona aleatoriamente un valor de la lista para el n칰mero de generaciones entre 100, 300 y 500

        # Ejecutar el algoritmo gen칠tico con los hiperpar치metros seleccionados en las iteraciones
        ga_modelo <- ga(
            type = "permutation", 
            fitness = function(x) -trayectoria(x),  # Funci칩n de fitness definida directamente dentro del c칩digo sin necesidad de crear una funci칩n aparte.
            lower = 1, upper = nrow(areas_protegidas),  
            popSize = n_poblacion,  
            maxiter = ngen,  
            pmutation = mutpb,  
            pcrossover = cxpb 
        )

        # Obtener la mejor soluci칩n y la distancia m칤nima para este conjunto de hiperpar치metros
        ruta_optima <- ga_modelo@solution[1, ]  # Extrae la mejor ruta obtenida
        distancia_optima <- -ga_modelo@fitnessValue  # La mejor distancia encontrada (negada porque el GA maximiza)

        # Comparar la distancia obtenida con la mejor distancia encontrada hasta ahora
        if (distancia_optima < mejor_distancia) {
            # Si encontramos una mejor distancia, actualizamos los mejores par치metros
        #Guardamos: tama침o de la poblaci칩n, probabilidades de mutaci칩n y cruce, n칰mero de generaciones, la mejor ruta y la mejor distancia, devolvemos en forma de lista
            mejor_distancia <- distancia_optima
            mejores_parametros <- list(
                n_poblacion = n_poblacion,  
                cxpb = cxpb,
                mutpb = mutpb,
                ngen = ngen,
                ruta_optima = ruta_optima, 
                distancia_optima = mejor_distancia 
            )
        }
    }

    return(mejores_parametros)  
}

# Ejecutar la b칰squeda de hiperpar치metros
mejores_parametros <- buscar_mejores_hiperparametros(hyper_iters = 10)

#Despu칠s de completar las 10 iteraciones, buscar_mejores_hiperparametros() devuelve una lista con los mejores valores encontrados luego de las 10 pruebas

# Mostrar los mejores hiperpar치metros encontrados
cat("Mejores hiperpar치metros encontrados:\n")
cat("Tama침o de poblaci칩n:", mejores_parametros$n_poblacion, "\n")
cat("Probabilidad de cruce:", round(mejores_parametros$cxpb, 2), "\n")
cat("Probabilidad de mutaci칩n:", round(mejores_parametros$mutpb, 2), "\n")
cat("N칰mero de generaciones:", mejores_parametros$ngen, "\n")
cat("Distancia 칩ptima:", mejores_parametros$distancia_optima, "km\n")


print(mejores_parametros)

```

### Simulaci칩n de costos

La simulaci칩n de costos tiene un car치cter **exploratorio** y se basa en supuestos simplificados:
- Un costo promedio por kil칩metro recorrido
- Un costo base asociado a entradas y gastos generales

Los valores utilizados no representan precios oficiales y se emplean 칰nicamente con fines ilustrativos.

```{r}
# Simulaci칩n de costos del mejor recorrido

# Definir costos
costo_por_km <- 800  #Pesos argentinos al d칤a de hoy 7/2/25, partiendo de $1128/L nafta
costo_base <- 202500  #Partiendo de un promedio de $13.500 para entradas de parques, teniendo en cuentra 15 parques

# Calcular costo total del recorrido 칩ptimo
costo_total <- (DistanciaOptima * costo_por_km) + costo_base

# Mostrar resultados de la simulaci칩n de costos
cat("\n*** Simulaci칩n de costos ***\n")
cat("Costo por kil칩metro:", costo_por_km, "$\n")
cat("Costo base del viaje:", costo_base, "$\n")
cat("Costo total estimado del recorrido 칩ptimo:", costo_total, "$\n")
```

### Aplicaci칩n interactiva

Se desarrolla una aplicaci칩n Shiny que permite:
- Modificar hiperpar치metros del algoritmo gen칠tico
- Visualizar din치micamente el recorrido 칩ptimo
- Explorar el impacto de los par치metros en el costo y la distancia

Esta interfaz transforma el modelo en una herramienta interactiva de an치lisis.


```{r}
library(shiny)
library(GA)
library(leaflet)
library(geosphere)
library(plotly)
library(tibble)  # Asegurar que tibble est치 disponible

# Definimos la interfaz de usuario
ui <- fluidPage(
  titlePanel("Optimizaci칩n de Recorridos entre Parques Nacionales Argentinos"),
  
  sidebarLayout(
    sidebarPanel(
      h3("Par치metros del Algoritmo Gen칠tico"),
      sliderInput("popSize", "Tama침o de Poblaci칩n:", min = 10, max = 100, value = 10, step = 5),
      sliderInput("cxpb", "Probabilidad de Cruce:", min = 0.4, max = 0.9, value = 0.5, step = 0.05),
      sliderInput("mutpb", "Probabilidad de Mutaci칩n:", min = 0.1, max = 0.3, value = 0.2, step = 0.05),
      sliderInput("ngen", "N칰mero de Generaciones:", min = 100, max = 500, value = 200, step = 50),
      
      actionButton("calcular", "Calcular"),
      h4("An치lisis de Costos"),
      textOutput("costo_text"),
      textOutput("ruta_optima_text")
    ),
    
    mainPanel(
      h3("Recorrido Optimizado"),
      leafletOutput("mapa_recorrido"),  # Asegurar que coincide con `output$mapa_recorrido`
      plotlyOutput("emoji_plot")
    )
  )
)

# Definimos el servidor
server <- function(input, output, session) {
  
  # Datos de las 치reas protegidas
  areas_protegidas <- tibble(
    Area_protegida = c("Parque Nacional Los Glaciares", "Parque Nacional Nahuel Huapi", 
                       "Parque Nacional Lan칤n", "Parque Nacional Perito Moreno", 
                       "Parque Nacional El Rey", "Parque Nacional Iguaz칰", 
                       "Parque Nacional Calilegua", "Parque Nacional Talampaya", 
                       "Parque Nacional Quebrada del Condorito", "Parque Nacional El Palmar", 
                       "Parque Nacional Campos del Tuy칰", "Parque Nacional Islas de Santa Fe", 
                       "Parque Nacional Mburucuy치", "Parque Nacional Chaco", "Parque Nacional Copo"),
    Latitud = c(-49.9, -42.8, -39.0, -47.2, -26.0, -25.7, -23.8, -29.8, -31.6, -31.8, -36.3, -32.9, -28.0, -26.8, -25.9),
    Longitud = c(-73.2, -71.8, -70.4, -71.3, -53.8, -54.5, -64.8, -68.1, -64.9, -58.1, -56.7, -60.7, -58.2, -59.6, -61.3)
  )
  
  n <- nrow(areas_protegidas)
  
  # Crear matriz de distancias
  D <- outer(1:n, 1:n, Vectorize(function(i, j) distGeo(
    c(areas_protegidas$Longitud[i], areas_protegidas$Latitud[i]),
    c(areas_protegidas$Longitud[j], areas_protegidas$Latitud[j])
  ) / 1000))
  
  # Funci칩n de fitness
  trayectoria <- function(recorrido) {
    sum(D[cbind(recorrido[-length(recorrido)], recorrido[-1])])
  }
  
  observeEvent(input$calcular, {
    ga_modelo <- ga(
      type = "permutation", 
      fitness = function(x) -trayectoria(x),
      lower = 1, upper = n, 
      popSize = input$popSize, 
      maxiter = input$ngen, 
      pmutation = input$mutpb, 
      pcrossover = input$cxpb
    )
    
    ruta_optima <- ga_modelo@solution[1, ]
    distancia_optima <- -ga_modelo@fitnessValue
    costo_estimado <- distancia_optima * 100
    
    output$costo_text <- renderText({
      paste("Costo estimado del recorrido optimizado:", round(costo_estimado, 2), "pesos argentinos")
    })
    
    output$ruta_optima_text <- renderText({
      paste("Distancia 칩ptima encontrada:", round(distancia_optima, 2), "km")
    })
    
    output$mapa_recorrido <- renderLeaflet({  # Nombre corregido
      req(input$calcular)  # Asegurar que el bot칩n se presiona antes de mostrar el mapa
      
      ruta_lat <- areas_protegidas$Latitud[ruta_optima]  
      ruta_lng <- areas_protegidas$Longitud[ruta_optima]  
      
      leaflet() %>%
        addProviderTiles("Esri.WorldImagery") %>%  
        setView(lng = mean(areas_protegidas$Longitud), lat = mean(areas_protegidas$Latitud), zoom = 5) %>%
        
        # A침adir las 치reas protegidas como marcadores
        addCircleMarkers(
          lng = areas_protegidas$Longitud, 
          lat = areas_protegidas$Latitud,
          color = "#228B22", # Verde oscuro
          fillColor = "#390c44", # Verde claro
          fillOpacity = 0.7,
          radius = 6,
          popup = areas_protegidas$Area_protegida
        ) %>%
        
        # Dibujar la l칤nea del recorrido 칩ptimo
        addPolylines(
          lng = ruta_lng, lat = ruta_lat, 
          color = "#006400", # Verde oscuro
          weight = 4,
          opacity = 0.7,
          dashArray = "10,5"  # L칤nea punteada
        )
    })
    
    output$emoji_plot <- renderPlotly({  # Faltaba renderizar plotly correctamente
      plot_ly(
        x = c(1),
        y = c(1),
        text = paste("Costo:", round(costo_estimado, 2), "游눯"),  # Agregu칠 un emoji de dinero
        mode = 'text',
        textfont = list(size = 36, color = "orange"),  
        hoverinfo = 'text'
      ) %>%
        layout(
          xaxis = list(title = '', zeroline = FALSE, showline = FALSE, showticklabels = FALSE),
          yaxis = list(title = '', zeroline = FALSE, showline = FALSE, showticklabels = FALSE)
        )
    })
  })
}

# Ejecutar la aplicaci칩n
shinyApp(ui = ui, server = server)
```

